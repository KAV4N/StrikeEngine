
#include "strikepch.h"
#include "Renderer.h"
#include <glm/gtc/matrix_transform.hpp>
#include "StrikeEngine/Renderer/ShaderManager.h"
#include "StrikeEngine/Renderer/ModelManager.h"
#include "StrikeEngine/Renderer/LightManager.h"
#include "StrikeEngine/Scene/Components/ModelComponent.h"

// TODO: REMOVE AFTER TESTING
#include <StrikeEngine/Scene/Systems/TransformSystem.h>
// ---------------------------------------------

namespace StrikeEngine {

    Renderer* Renderer::s_Instance = nullptr;

    Renderer::Renderer()
        : m_DefaultTexture(nullptr), m_Skybox(nullptr), m_RenderSkybox(false),
        m_Width(1280), m_Height(720), m_FullScreenQuadShader(nullptr) {
        SetupFullScreenQuad();
    }

    Renderer::~Renderer() {
        if (m_DefaultTexture) {
            delete m_DefaultTexture;
        }
        if (m_Skybox) {
            delete m_Skybox;
        }

        glDeleteFramebuffers(1, &m_Framebuffer);
        glDeleteTextures(1, &m_ColorAttachment);
        glDeleteRenderbuffers(1, &m_DepthAttachment);

        glDeleteVertexArrays(1, &m_QuadVAO);
        glDeleteBuffers(1, &m_QuadVBO);

        delete m_FullScreenQuadShader;
    }

    void Renderer::Create() {
        if (!s_Instance) {
            s_Instance = new Renderer();
        }
    }

    Renderer* Renderer::Get() {
        return s_Instance;
    }

    void Renderer::Destroy() {
        if (s_Instance) {
            delete s_Instance;
            s_Instance = nullptr;
        }
    }

    void Renderer::Init() {
        ModelManager::Create();
        ShaderManager::Create();
        LightManager::Create();

        glEnable(GL_DEPTH_TEST);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        m_FullScreenQuadShader = ShaderManager::Get()->GetShader("ScreenShader");
        CreateFramebuffer();
    }

    void Renderer::CreateFramebuffer() {
        // Delete existing framebuffer if it exists
        if (m_Framebuffer) {
            glDeleteFramebuffers(1, &m_Framebuffer);
            glDeleteTextures(1, &m_ColorAttachment);
            glDeleteRenderbuffers(1, &m_DepthAttachment);
        }

        // Create new framebuffer
        glGenFramebuffers(1, &m_Framebuffer);
        glBindFramebuffer(GL_FRAMEBUFFER, m_Framebuffer);

        // Color attachment
        glGenTextures(1, &m_ColorAttachment);
        glBindTexture(GL_TEXTURE_2D, m_ColorAttachment);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, m_Width, m_Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_ColorAttachment, 0);

        // Depth attachment
        glGenRenderbuffers(1, &m_DepthAttachment);
        glBindRenderbuffer(GL_RENDERBUFFER, m_DepthAttachment);
        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, m_Width, m_Height);
        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_DepthAttachment);

        if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
            std::cerr << "Framebuffer is not complete!" << std::endl;
        }

        glBindFramebuffer(GL_FRAMEBUFFER, 0);
    }

    void Renderer::BeginScene(CameraComponent* camera) {
        LightManager::Get()->BindLightsToShader();
        RenderShadowMaps();

        glBindFramebuffer(GL_FRAMEBUFFER, m_Framebuffer);
        glViewport(0, 0, m_Width, m_Height); 
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        m_CameraViewProjectionMatrix = camera->ProjectionMatrix * camera->ViewMatrix;
        m_CameraViewMatrix = camera->ViewMatrix;
        m_CameraProjectionMatrix = camera->ProjectionMatrix;
        m_CameraPosition = camera->Position;
    }

    void Renderer::EndScene() {
        Render();
        
        glBindFramebuffer(GL_FRAMEBUFFER, 0); 
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        m_FullScreenQuadShader->Bind();
        glBindTexture(GL_TEXTURE_2D, m_ColorAttachment);
        RenderFullScreenQuad();
        glBindTexture(GL_TEXTURE_2D, 0);
        m_FullScreenQuadShader->Unbind();

        LightManager::Get()->UnBindLightsToShader();
    }

    void Renderer::SubmitScene(Scene* scene) {
        const auto view = scene->GetRegistry().view<ModelComponent, TransformComponent>();
        for (auto entityHandle : view) {
            Entity entity{ entityHandle, scene };
            /*
            // TODO: REMOVE AFTER TESTING-----------------------------------------
            TransformSystem::IncreaseRotation(entity, glm::uvec3(0.f, 0.f, 1.f));
            auto& modelComp = entity.GetComponent<ModelComponent>();
            modelComp.parts[0].rotation += glm::vec3(0.0f, 0.0f, 45.0f);
            //---------------------------------------------------------------------
            */
            auto& transform = entity.GetComponent<TransformComponent>().transformationMatrix;
            SubmitEntity(entity, transform);
        }
    }

    void Renderer::SubmitEntity(Entity entity, const glm::mat4& transformationMatrix) {
        auto& modelComp = entity.GetComponent<ModelComponent>();
        Shader* shader = modelComp.model->GetShader();
        m_RenderQueue[shader].push_back({ transformationMatrix, entity, m_CameraPosition });
    }

    void Renderer::SubmitSkybox(Skybox* skybox) {
        m_Skybox = skybox;
        m_RenderSkybox = true;
    }

    void Renderer::RenderShadowMaps() {
        for (auto& pair : m_RenderQueue) {
            for (const auto& command : pair.second) {
                const auto& modelComp = command.entity.GetComponent<ModelComponent>();
                for (const auto& partComp : modelComp.parts) {
                    glm::mat4 partTransform = command.transformationMatrix * partComp.localTransform;
                    LightManager::Get()->UpdateShadowMaps(partComp, partTransform);
                }
            }
        }
    }


    void Renderer::Render() {
        
        RenderSkybox();

        for (auto& pair : m_RenderQueue) {
            Shader* shader = pair.first;
            shader->Bind();

            for (const auto& command : pair.second) {
                BindShaderMVP(shader, command);
                RenderModelParts(shader, command);
            }

            shader->Unbind();
        }
        
        m_RenderQueue.clear();
        
    }

    void Renderer::RenderSkybox() {
        if (m_Skybox) {
            glDepthFunc(GL_LEQUAL);
            glDisable(GL_DEPTH_TEST);

            Shader* skyboxShader = m_Skybox->GetShader();
            skyboxShader->Bind();

            glm::mat4 view = glm::mat4(glm::mat3(m_CameraViewMatrix));
            skyboxShader->LoadUniform("MVP", m_CameraProjectionMatrix * view);

            m_Skybox->Draw();

            glDepthFunc(GL_LESS);
            glEnable(GL_DEPTH_TEST);
            skyboxShader->Unbind();
        }
    }

    void Renderer::BindShaderMVP(Shader* shader, const RenderCommand& command) {
        shader->LoadUniform("MVP", m_CameraProjectionMatrix * m_CameraViewMatrix);
        shader->LoadUniform("viewPosition", m_CameraPosition);
    }

    void Renderer::BindShaderMaterials(Shader* shader, ModelPart* part) {
        const Material& material = part->GetMaterial();
        shader->LoadUniform("material.ambient", material.ambient);
        shader->LoadUniform("material.diffuse", material.diffuse);
        shader->LoadUniform("material.specular", material.specular);
        shader->LoadUniform("material.shininess", material.shininess);
    }

    void Renderer::RenderModelParts(Shader* shader, const RenderCommand& command) {
        const auto& modelComp = command.entity.GetComponent<ModelComponent>();
        for (const auto& partComp : modelComp.parts) {
            glm::mat4 partTransform = command.transformationMatrix * partComp.localTransform;
            BindShaderMaterials(shader, partComp.part);
            BindTextures(partComp.part);

            shader->LoadUniform("transform", partTransform);

            partComp.part->Draw(shader);

            UnbindTextures(partComp.part);
        }
    }

    void Renderer::BindTextures(ModelPart* part) {
        int textureUnit = 0;

        if (part->GetTextures().empty() && m_DefaultTexture) {
            m_DefaultTexture->Bind(textureUnit);
        }
        else {
            for (const auto& texture : part->GetTextures()) {
                texture->Bind(textureUnit);
                textureUnit++;
            }
        }
    }

    void Renderer::UnbindTextures(ModelPart* part) {
        if (part->GetTextures().empty() && m_DefaultTexture) {
            m_DefaultTexture->Unbind();
        }
        else {
            for (const auto& texture : part->GetTextures()) {
                texture->Unbind();
            }
        }
    }

    void Renderer::SetDefaultTexture(const std::string& path) {
        if (m_DefaultTexture) {
            delete m_DefaultTexture;
        }
        m_DefaultTexture = new Texture(path);
    }

    void Renderer::SetupFullScreenQuad() {
        float vertices[] = {
            // positions   // texture Coords
            -1.0f,  1.0f,  0.0f, 1.0f,
            -1.0f, -1.0f,  0.0f, 0.0f,
             1.0f, -1.0f,  1.0f, 0.0f,

            -1.0f,  1.0f,  0.0f, 1.0f,
             1.0f, -1.0f,  1.0f, 0.0f,
             1.0f,  1.0f,  1.0f, 1.0f
        };

        glGenVertexArrays(1, &m_QuadVAO);
        glGenBuffers(1, &m_QuadVBO);
        glBindVertexArray(m_QuadVAO);
        glBindBuffer(GL_ARRAY_BUFFER, m_QuadVBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float)));
        glEnableVertexAttribArray(0);
        glEnableVertexAttribArray(1);
    }

    void Renderer::RenderFullScreenQuad() {
        glBindVertexArray(m_QuadVAO);
        glDrawArrays(GL_TRIANGLES, 0, 6);
        glBindVertexArray(0);
    }
}
#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <unordered_map>
#include <entt/entt.hpp>
#include "StrikeEngine/Scene/Camera.h"
#include "StrikeEngine/Renderer/Shader.h"
#include "StrikeEngine/Renderer/Model.h"
#include "StrikeEngine/Renderer/Texture.h"
#include "StrikeEngine/Scene/Entity.h"
#include "StrikeEngine/Scene/Components/CameraComponent.h"
#include "StrikeEngine/Scene/Components/TransformComponents.h"
#include "Skybox.h"
#include <StrikeEngine/Scene/Components/ModelComponent.h>

namespace StrikeEngine {

    struct RenderCommand {
        glm::mat4 transformationMatrix;
        Entity entity;
        glm::vec3 cameraPosition;
    };

    class Renderer {
    public:
        static void Create();
        static Renderer* Get();
        static void Destroy();
        void Init();

        void BeginScene(CameraComponent* camera);
        void EndScene();
        void SubmitScene(Scene* scene);
        void SubmitSkybox(Skybox* skybox);
        void Render();
        void RenderShadowMaps();

        void SetDefaultTexture(const std::string& path);

    private:
        Renderer();
        ~Renderer();

        void RenderSkybox();
        void SubmitEntity(Entity entity, const glm::mat4& transformationMatrix);
        void BindShaderMVP(Shader* shader, const RenderCommand& command);
        void BindShaderMaterials(Shader* shader, ModelPart* part);
        void RenderModelParts(Shader* shader, const RenderCommand& command);
        void BindTextures(ModelPart* part);
        void UnbindTextures(ModelPart* part);

        void CreateFramebuffer();
        // Full-screen quad setup
        void SetupFullScreenQuad();
        void RenderFullScreenQuad();

        static Renderer* s_Instance;
        std::unordered_map<Shader*, std::vector<RenderCommand>> m_RenderQueue;
        Skybox* m_Skybox;
        bool m_RenderSkybox;
        Texture* m_DefaultTexture;

        GLuint m_Framebuffer;
        GLuint m_ColorAttachment;
        GLuint m_DepthAttachment;
        GLuint m_Width;
        GLuint m_Height;

        GLuint m_QuadVAO, m_QuadVBO;
        Shader* m_FullScreenQuadShader;

        glm::mat4 m_CameraViewProjectionMatrix;
        glm::mat4 m_CameraViewMatrix;
        glm::mat4 m_CameraProjectionMatrix;
        glm::vec3 m_CameraPosition;
    };
}