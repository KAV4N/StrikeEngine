what are here opengl texture slots?

```glsl
#type VERTEX
#version 430 core

layout (location = 0) in vec3 aPosition;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;
layout (location = 3) in vec3 aTangent;
layout (location = 4) in vec3 aBiNormal;
layout (location = 5) in mat4 aInstanceModel;

uniform mat4 uViewProjection;
uniform mat4 uView;
uniform mat4 uLightSpaceMatrix;

out VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoords;
    vec4 FragPosLightSpace;
    mat3 TBN;
} vs_out;

void main() {
    vec3 worldPos = vec3(aInstanceModel * vec4(aPosition, 1.0));
    vs_out.FragPos = worldPos;


    mat3 normalMatrix = transpose(inverse(mat3(aInstanceModel)));

    vs_out.Normal = normalize(normalMatrix * aNormal);
    vs_out.TexCoords = aTexCoord;
    vs_out.FragPosLightSpace = uLightSpaceMatrix * vec4(worldPos, 1.0);
    
    vec3 T = normalize(normalMatrix * aTangent);
    vec3 N = normalize(normalMatrix * aNormal);
    T = normalize(T - dot(T, N) * N);
    vec3 B = cross(N, T);

    mat3 TBN = mat3(T, B, N);  
    
    gl_Position = uViewProjection * vec4(worldPos, 1.0);
}

#type FRAGMENT
#version 430 core

out vec4 FragColor;

in VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoords;
    vec4 FragPosLightSpace;
    mat3 TBN;
} fs_in;


uniform sampler2D uShadowMap;

struct Material {
    vec3 baseColor;
    float metallic;
    float roughness;
    int hasBaseColorMap;
    int hasNormalMap;
    int hasMetallicMap;
    int hasRoughnessMap;
    sampler2D baseColorMap;
    sampler2D normalMap;
    sampler2D metallicMap;
    sampler2D roughnessMap;
};

struct Sun {
    vec3 direction;
    vec3 color;
    float intensity;
};

struct PointLight {
    vec4 position;
    vec4 color;
    float intensity;
    float radius;
    float fallOff;
};

layout(std430, binding = 2) restrict buffer lightSSBO {
    PointLight pointLight[];
};

uniform Material uMaterial;
uniform Sun uSun;
uniform int uCastShadows;

uniform int uNumPointLights;
uniform vec3 uViewPos;

const float PI = 3.14159265359;

vec3 getBaseColor() {
    if (uMaterial.hasBaseColorMap == 1) {
        return texture(uMaterial.baseColorMap, fs_in.TexCoords).rgb;
    }
    return uMaterial.baseColor;
}

vec3 getNormal() {
    if (uMaterial.hasNormalMap == 1) {
        vec3 normal = texture(uMaterial.normalMap, fs_in.TexCoords).rgb;
        normal = normalize(normal * 2.0 - 1.0);
        return normalize(fs_in.TBN * normal);
    }
    return normalize(fs_in.Normal);
}

float getMetallic() {
    if (uMaterial.hasMetallicMap == 1) {
        return texture(uMaterial.metallicMap, fs_in.TexCoords).r;
    }
    return uMaterial.metallic;
}

float getRoughness() {
    if (uMaterial.hasRoughnessMap == 1) {
        return texture(uMaterial.roughnessMap, fs_in.TexCoords).r;
    }
    return uMaterial.roughness;
}

float calculateShadow(vec4 fragPosLightSpace, vec3 normal, vec3 lightDir) {
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    if (projCoords.z > 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || 
        projCoords.y < 0.0 || projCoords.y > 1.0) {
        return 0.0;
    }
    
    float closestDepth = texture(uShadowMap, projCoords.xy).r;
    float currentDepth = projCoords.z;
    float bias = max(0.005 * (1.0 - dot(normal, lightDir)), 0.0005);
    
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(uShadowMap, 0);
    
    for(int x = -1; x <= 1; ++x) {
        for(int y = -1; y <= 1; ++y) {
            float pcfDepth = texture(uShadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0;
    
    return shadow;
}

vec3 calculatePointLight(PointLight light, vec3 fragPos, vec3 normal, vec3 albedo) {
    vec3 lightPos = light.position.xyz;
    vec3 lightDir = normalize(lightPos - fragPos);
    
    float distance = length(lightPos - fragPos);
    if (distance > light.radius) return vec3(0.0);
    
    float atten = pow(1.0 / (1.0 + distance / light.radius), light.fallOff);
    vec3 lightColor = light.color.rgb * light.intensity * atten;
    
    float diff = max(dot(normal, lightDir), 0.0);
    
    return diff * lightColor * albedo;
}

vec3 calculateSunLight(Sun sun, vec3 normal, vec3 albedo, float shadow) {
    vec3 lightDir = normalize(-sun.direction);
    vec3 lightColor = sun.color * sun.intensity;
    
    float diff = max(dot(normal, lightDir), 0.0);
    
    return diff * lightColor * albedo * (1.0 - shadow);
}

void main() {
    vec3 normal = getNormal();
    vec3 albedo = getBaseColor();
    
    vec3 color = vec3(0.0);

    float shadow = 0.0;
    if (uCastShadows == 1) {
        shadow = calculateShadow(fs_in.FragPosLightSpace, normal, normalize(-uSun.direction));
    }
    color += calculateSunLight(uSun, normal, albedo, shadow);

    for (int i = 0; i < uNumPointLights; ++i) {
        PointLight light = pointLight[i];
        color += calculatePointLight(light, fs_in.FragPos, normal, albedo);
    }

    FragColor = vec4(color, 1.0);
}
```