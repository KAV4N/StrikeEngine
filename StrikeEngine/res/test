// ========================================================
// COMPUTE SHADER - Cluster Building
// ========================================================
#type COMPUTE
#version 430 core
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
struct Cluster
{
    vec4 minPoint;
    vec4 maxPoint;
    uint count;
    uint lightIndices[100];
};
layout(std430, binding = 1) buffer clusterSSBO
{
    Cluster clusters[];
};
uniform float uZNear;
uniform float uZFar;
uniform mat4 uInverseProjection;
uniform uvec3 uGridSize;
uniform uvec2 uScreenDimensions;
vec3 screenToView(vec2 screenCoord);
vec3 lineIntersectionWithZPlane(vec3 startPoint, vec3 endPoint, float zDistance);
void main()
{
    const vec3 eyePos = vec3(0.0);
    uint tileIndex =
        gl_WorkGroupID.x +
        gl_WorkGroupID.y * uGridSize.x +
        gl_WorkGroupID.z * uGridSize.x * uGridSize.y;
    vec2 tileSize = vec2(uScreenDimensions) / vec2(uGridSize.xy);
    vec2 minPoint_screenSpace = gl_WorkGroupID.xy * tileSize;
    vec2 maxPoint_screenSpace = (gl_WorkGroupID.xy + 1) * tileSize;
    vec3 minPoint_viewSpace = screenToView(minPoint_screenSpace);
    vec3 maxPoint_viewSpace = screenToView(maxPoint_screenSpace);
    float tileNear =
        uZNear * pow(uZFar / uZNear, float(gl_WorkGroupID.z) / float(uGridSize.z));
    float tileFar =
        uZNear * pow(uZFar / uZNear, float(gl_WorkGroupID.z + 1) / float(uGridSize.z));
    vec3 minPointNear =
        lineIntersectionWithZPlane(eyePos, minPoint_viewSpace, tileNear);
    vec3 minPointFar =
        lineIntersectionWithZPlane(eyePos, minPoint_viewSpace, tileFar);
    vec3 maxPointNear =
        lineIntersectionWithZPlane(eyePos, maxPoint_viewSpace, tileNear);
    vec3 maxPointFar =
        lineIntersectionWithZPlane(eyePos, maxPoint_viewSpace, tileFar);
    vec3 minPointAABB = min(minPointNear, minPointFar);
    vec3 maxPointAABB = max(maxPointNear, maxPointFar);
    clusters[tileIndex].minPoint = vec4(minPointAABB, 0.0);
    clusters[tileIndex].maxPoint = vec4(maxPointAABB, 0.0);
}
vec3 lineIntersectionWithZPlane(vec3 startPoint, vec3 endPoint, float zDistance)
{
    vec3 direction = endPoint - startPoint;
    vec3 normal = vec3(0.0, 0.0, -1.0);
    float t = (zDistance - dot(normal, startPoint)) / dot(normal, direction);
    return startPoint + t * direction;
}
vec3 screenToView(vec2 screenCoord)
{
    vec4 ndc = vec4(
        screenCoord / vec2(uScreenDimensions) * 2.0 - 1.0,
        -1.0,
        1.0
    );
    vec4 viewCoord = uInverseProjection * ndc;
    viewCoord /= viewCoord.w;
    return viewCoord.xyz;
}
// ========================================================
// COMPUTE SHADER - Light Culling
// ========================================================
#type COMPUTE
#version 430 core
#define LOCAL_SIZE 128
layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;
struct PointLight
{
    vec4 position;
    vec4 color;
    float intensity;
    float radius;
};
struct Cluster
{
    vec4 minPoint;
    vec4 maxPoint;
    uint count;
    uint lightIndices[100];
};
layout(std430, binding = 1) restrict buffer clusterSSBO
{
    Cluster clusters[];
};
layout(std430, binding = 2) restrict buffer lightSSBO
{
    PointLight pointLight[];
};
uniform mat4 uViewMatrix;
bool testSphereAABB(uint i, Cluster c);
void main()
{
    uint lightCount = pointLight.length();
    uint index = gl_WorkGroupID.x * LOCAL_SIZE + gl_LocalInvocationID.x;
    Cluster cluster = clusters[index];
    cluster.count = 0;
    for (uint i = 0; i < lightCount; ++i)
    {
        if (testSphereAABB(i, cluster) && cluster.count < 100)
        {
            cluster.lightIndices[cluster.count] = i;
            cluster.count++;
        }
    }
    clusters[index] = cluster;
}
bool sphereAABBIntersection(vec3 center, float radius, vec3 aabbMin, vec3 aabbMax)
{
    vec3 closestPoint = clamp(center, aabbMin, aabbMax);
    float distanceSquared = dot(closestPoint - center, closestPoint - center);
    return distanceSquared <= radius * radius;
}
bool testSphereAABB(uint i, Cluster cluster)
{
    vec3 center = vec3(uViewMatrix * pointLight[i].position);
    float radius = pointLight[i].radius;
    vec3 aabbMin = cluster.minPoint.xyz;
    vec3 aabbMax = cluster.maxPoint.xyz;
    return sphereAABBIntersection(center, radius, aabbMin, aabbMax);
}
// ========================================================
// VERTEX SHADER
// ========================================================
#type VERTEX
#version 430 core
layout (location = 0) in vec3 aPosition;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;
layout (location = 4) in mat4 aInstanceModel;
uniform mat4 uView;
uniform mat4 uProjection;
uniform mat4 uLightSpaceMatrix;
out VS_OUT {
    vec3 FragPosViewSpace; // View space position
    vec3 NormalViewSpace; // View space normal
    vec2 TexCoords;
    vec4 FragPosLightSpace;
} vs_out;
void main() {
    vec4 worldPos = aInstanceModel * vec4(aPosition, 1.0);
    vec4 viewPos = uView * worldPos;
    
    // Normal matrix: transpose(inverse(mat3(view * model)))
    mat3 normalMatrix = transpose(inverse(mat3(uView * aInstanceModel)));
    
    vs_out.FragPosViewSpace = viewPos.xyz;
    vs_out.NormalViewSpace = normalize(normalMatrix * aNormal);
    vs_out.TexCoords = aTexCoord;
    vs_out.FragPosLightSpace = uLightSpaceMatrix * worldPos;
    
    gl_Position = uProjection * viewPos;
}
// ========================================================
// FRAGMENT SHADER
// ========================================================
#type FRAGMENT
#version 430 core
out vec4 FragColor;
in VS_OUT {
    vec3 FragPosViewSpace; // View space position
    vec3 NormalViewSpace; // View space normal
    vec2 TexCoords;
    vec4 FragPosLightSpace;
} fs_in;
struct Sun {
    vec3 direction; // World space direction
    vec3 color;
    float intensity;
};
struct PointLight {
    vec4 position; // World space position
    vec4 color;
    float intensity;
    float radius;
};
struct Cluster {
    vec4 minPoint;
    vec4 maxPoint;
    uint count;
    uint lightIndices[100];
};
layout(std430, binding = 2) buffer lightSSBO {
    PointLight pointLight[];
};
layout(std430, binding = 1) buffer clusterSSBO {
    Cluster clusters[];
};
uniform Sun uSun;
uniform int uCastShadows;
uniform sampler2D uShadowMap;
uniform vec4 uColorBlend;
uniform sampler2D uTexture;
uniform mat4 uView;
uniform float uZNear;
uniform float uZFar;
uniform uvec3 uGridSize;
uniform uvec2 uScreenDimensions;
const float PI = 3.14159265359;
// ---------------------------
vec3 getBaseColor()
{
    vec3 texColor = texture(uTexture, fs_in.TexCoords).rgb;
    return mix(texColor, uColorBlend.rgb, uColorBlend.a);
}
// ---------------------------
float calculateShadow(vec3 lightDirViewSpace)
{
    vec3 projCoords = fs_in.FragPosLightSpace.xyz / fs_in.FragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    if (projCoords.z > 1.0 ||
        projCoords.x < 0.0 || projCoords.x > 1.0 ||
        projCoords.y < 0.0 || projCoords.y > 1.0)
        return 0.0;
    float currentDepth = projCoords.z;
    float bias = max(0.005 * (1.0 - dot(fs_in.NormalViewSpace, lightDirViewSpace)), 0.0005);
    float shadow = 0.0;
    vec2 texelSize = 1.0 / vec2(textureSize(uShadowMap, 0));
    for (int x = -1; x <= 1; ++x) {
        for (int y = -1; y <= 1; ++y) {
            float pcfDepth = texture(uShadowMap, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
        }
    }
    return shadow / 9.0;
}
// ---------------------------
vec3 calculateSunLight(vec3 viewDirection, vec3 albedo)
{
    // Convert sun direction from world space to view space
    vec3 lightDirViewSpace = normalize(mat3(uView) * (-uSun.direction));
    vec3 halfwayDir = normalize(viewDirection + lightDirViewSpace);
    float NdotL = max(dot(fs_in.NormalViewSpace, lightDirViewSpace), 0.0);
    float NdotH = max(dot(fs_in.NormalViewSpace, halfwayDir), 0.0);
    float shadowFactor = (uCastShadows == 1) ? calculateShadow(lightDirViewSpace) : 0.0;
    vec3 diffuse = albedo * uSun.color * uSun.intensity * NdotL;
    vec3 specular = vec3(0.2) * uSun.color * uSun.intensity * pow(NdotH, 32.0);
    return (diffuse + specular) * (1.0 - shadowFactor);
}
// ---------------------------
vec3 calculatePointLight(PointLight light, vec3 viewDirection, vec3 albedo)
{
    // Convert light position from world space to view space
    vec3 lightPosViewSpace = vec3(uView * light.position);
    
    vec3 fragToLight = lightPosViewSpace - fs_in.FragPosViewSpace;
    vec3 lightDir = normalize(fragToLight);
    vec3 halfwayDir = normalize(viewDirection + lightDir);
    float distance = length(fragToLight);
    if (distance > light.radius) return vec3(0.0);
    float attenuation = 1.0 / (1.0 + distance * distance * 0.1);
    float edgeFade = 1.0 - smoothstep(light.radius * 0.7, light.radius, distance);
    attenuation *= edgeFade;
    float NdotL = max(dot(fs_in.NormalViewSpace, lightDir), 0.0);
    float NdotH = max(dot(fs_in.NormalViewSpace, halfwayDir), 0.0);
    vec3 diffuse = albedo * light.color.rgb * light.intensity * NdotL * attenuation;
    vec3 specular = vec3(0.2) * light.color.rgb * light.intensity * pow(NdotH, 32.0) * attenuation;
    return diffuse + specular;
}
// ---------------------------
uint getClusterIndex()
{
    // Convert view space depth to cluster Z index
    float viewZ = -fs_in.FragPosViewSpace.z; // Positive depth
    
    // Logarithmic depth slicing
    uint zSlice = uint(max(log(viewZ / uZNear) * float(uGridSize.z) / log(uZFar / uZNear), 0.0));
    zSlice = min(zSlice, uGridSize.z - 1);
    
    // Screen space tile indices
    vec2 tileSize = vec2(uScreenDimensions) / vec2(uGridSize.xy);
    uvec2 tileID = uvec2(gl_FragCoord.xy / tileSize);
    tileID = min(tileID, uGridSize.xy - uvec2(1));
    
    uint tileIndex = tileID.x +
                     tileID.y * uGridSize.x +
                     zSlice * uGridSize.x * uGridSize.y;
    
    return tileIndex;
}
// ---------------------------
void main()
{
    // View direction in view space (towards camera at origin)
    vec3 viewDirection = normalize(-fs_in.FragPosViewSpace);
    vec3 albedo = getBaseColor();
    vec3 radiance = vec3(0.0);
    // Sun / directional light
    radiance += calculateSunLight(viewDirection, albedo);
    // Clustered point lights
    uint clusterIndex = getClusterIndex();
    uint lightCount = clusters[clusterIndex].count;
    for (uint i = 0u; i < lightCount; ++i) {
        uint lightIndex = clusters[clusterIndex].lightIndices[i];
        radiance += calculatePointLight(pointLight[lightIndex], viewDirection, albedo);
    }
    // Ambient
    vec3 ambient = vec3(0.03) * albedo;
    FragColor = vec4(ambient + radiance, 1.0);
}